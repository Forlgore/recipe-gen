name: Ingest Recipe from Issue (append to Repo B .recipes[])

on:
  issues:
    types: [opened]  # Must be on default branch to trigger on repo events. [1](https://docs.github.com/en/rest/authentication/permissions-required-for-fine-grained-personal-access-tokens)

jobs:
  ingest:
    runs-on: ubuntu-latest

    steps:
      - name: Check out Repo A
        uses: actions/checkout@v4

      # Optional only if you keep the normalization helper in Repo A (tools/generate_recipe_json.js)
      - name: Set up Node.js (optional)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Extract JSON payload from issue body
        id: extract
        run: |
          set -euo pipefail

          printf "%s" '${{ github.event.issue.body }}' > body.txt

          # Take the first fenced ```json ... ``` block from the issue body
          awk 'BEGIN{injson=0} /^```json/{injson=1; next} /^```/{if(injson==1){exit}} {if(injson==1) print}' body.txt > recipe.input.json || true

          # Sanity checks
          if ! [ -s recipe.input.json ]; then
            echo "No JSON payload found in the issue body fenced block."
            exit 1
          fi

          # Validate JSON syntax
          jq . recipe.input.json > /dev/null

          echo "JSON_FILE=recipe.input.json" >> "$GITHUB_ENV"

      # -------- OPTIONAL NORMALIZATION --------
      # Keep this step IF you included tools/generate_recipe_json.js in Repo A.
      # Otherwise, remove this step and keep JSON_FILE pointing to recipe.input.json.
      - name: Normalize/validate payload (optional)
        run: |
          node tools/generate_recipe_json.js
          echo "JSON_FILE=generated_recipe.json" >> "$GITHUB_ENV"
      # ----------------------------------------

      - name: Append recipe to Repo B (data/recipes.json -> .recipes[])
        env:
          GH_TOKEN: ${{ secrets.generator }}   # Fine-grained PAT with Contents: read & write on Repo B
        run: |
          set -euo pipefail

          # ---------- CONFIGURE YOUR TARGET REPOSITORY (Repo B) ----------
          TARGET_REPO_OWNER="Forlgore"                 # <-- set to Repo B owner
          TARGET_REPO_NAME="recipe-frontend"           # <-- set to Repo B name
          TARGET_FILE_PATH="data/recipes.json"         # <-- set if path differs
          TARGET_BRANCH="main"                         # <-- set to Repo B default branch
          # ----------------------------------------------------------------

          FILE_URL="https://api.github.com/repos/$TARGET_REPO_OWNER/$TARGET_REPO_NAME/contents/$TARGET_FILE_PATH?ref=$TARGET_BRANCH"

          # Fetch current file (to get sha and current content)
          HTTP_STATUS=$(
            curl -sS -w "%{http_code}" -o response.json \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$FILE_URL"
          )

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "ERROR: Expected existing object with .recipes array in Repo B. HTTP status: $HTTP_STATUS"
            echo "The ingest workflow is configured for an object-shaped file: { \"recipes\": [ ... ] }"
            cat response.json || true
            exit 1
          fi

          # Decode current content and confirm structure: { "recipes": [ ... ] }
          jq -r '.content' < response.json | tr -d '\n' | base64 -d > current.json
          if ! jq -e 'type=="object" and has("recipes") and .recipes|type=="array"' current.json > /dev/null; then
            echo "ERROR: Repo B file is not an object with a .recipes array."
            echo "Observed structure:"
            jq 'type as $t | {type:$t, keys: (keys? // [])}' current.json || true
            exit 1
          fi

          # Merge: append the new item strictly into .recipes[]
          jq --slurp '.[0] as $cur | .[1] as $new
              | if ($cur|has("recipes") and ($cur.recipes|type=="array"))
                then $cur | .recipes = (.recipes + [$new])
                else $cur
                end' current.json "$JSON_FILE" > merged.json

          # Prepare commit message (use recipe name if available)
          COMMIT_MSG="Append recipe to recipes.json (issue ingest)"
          NAME_FROM_JSON="$(jq -r 'try .name // empty' "$JSON_FILE")"
          if [ -n "$NAME_FROM_JSON" ]; then
            COMMIT_MSG="Append: ${NAME_FROM_JSON}"
          fi

          # Base64-encode new content (required by GitHub Create/Update Contents API)
          NEW_CONTENT_B64="$(base64 -w 0 < merged.json)"

          SHA="$(jq -r '.sha' < response.json)"

          BODY="$(
            jq -n \
              --arg message "$COMMIT_MSG" \
              --arg content "$NEW_CONTENT_B64" \
              --arg branch "$TARGET_BRANCH" \
              --arg sha "$SHA" \
              '{message:$message, content:$content, sha:$sha, branch:$branch}'
          )"

          UPDATE_URL="https://api.github.com/repos/$TARGET_REPO_OWNER/$TARGET_REPO_NAME/contents/$TARGET_FILE_PATH"

          # PUT /repos/{owner}/{repo}/contents/{path} â€” Create or update file contents
          curl -sS -X PUT \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            -d "$BODY" \
            "$UPDATE_URL" | tee update_response.json
          # Uses the documented Contents API which requires Base64 and file sha for updates. [2](https://github.com/actions/setup-node/releases)

      - name: Comment result & close issue (optional)
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          issue_number='${{ github.event.issue.number }}'
          if [ -f update_response.json ]; then
            echo "Thanks! Your recipe has been appended to Repo B (.recipes[])." > comment.md
          else
            echo "We attempted to process your recipe, but an error occurred. Please check the workflow logs." > comment.md
          fi
          gh api repos/${{ github.repository }}/issues/$issue_number/comments -f body="$(cat comment.md)"
          # Close the issue (optional)
          gh api repos/${{ github.repository }}/issues/$issue_number -X PATCH -f state=closed
